<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/index.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/cchamberlain/process-mux" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-processMux">processMux</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-EXIT">EXIT</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import Promise from &apos;bluebird&apos;
import co from &apos;co&apos;
import { createLogger } from &apos;bunyan&apos;
import cp from &apos;child_process&apos;
import { inspect } from &apos;util&apos;
import chai from &apos;chai&apos;
const should = chai.should()

const PMUX = &apos;PMUX&apos;
const ROOT = &apos;ROOT&apos;
const INIT = &apos;INIT&apos;
const REDUCE = &apos;REDUCE&apos;
const NO_INIT = &apos;NO_INIT&apos;
const SYNC_ERROR = &apos;SYNC_ERROR&apos;
const FORK_ERROR = &apos;FORK_ERROR&apos;
export const EXIT = &apos;EXIT&apos;

function pmuxAction(...args) {
  const [type, payload] = args
  if(!type)
    return
  return ({ type, payload })
}

const createFork = ({ timeoutMS }) =&gt; (...args) =&gt; new Promise((resolve, reject) =&gt; {
  let timeoutID = null
  try {
    timeoutMS.should.be.a(&apos;number&apos;)
    args.should.be.an(&apos;array&apos;).and.have.length.within(1, 3)
    const child = cp.fork(...args)
    timeoutID = setTimeout(() =&gt; {
      if(child.stdin)
        child.stdin.pause()
      child.kill()
      reject(new Error(NO_INIT))
    }, timeoutMS)
    child.on(&apos;close&apos;, () =&gt; reject(new Error(&apos;CLOSE_BEFORE_INIT&apos;)))
    child.on(&apos;disconnect&apos;, () =&gt; console.warn(&apos;DISCONNECT&apos;))
    child.on(&apos;error&apos;, err =&gt; reject(err))
    child.on(&apos;exit&apos;, () =&gt; reject(new Error(&apos;EXIT_BEFORE_INIT&apos;)))
    child.on(&apos;message&apos;, action =&gt; {
      if(action.type === INIT) {
        clearTimeout(timeoutID)
        resolve(child)
      }
    })
  } catch(err) {
    clearTimeout(timeoutID)
    reject(err)
  }
})


export default function processMux( { log = createLogger({ name: &apos;process-mux&apos; })
                                    , timeoutMS = 4000
                                    } = {} ) {

  const orphan = typeof process.env[PMUX] === &apos;undefined&apos;
  let forks = new Map()
  let state = {}
  let reducers = {}
  let reduceState = (state, action) =&gt; {
    let forkIDs = Array.from(forks.keys())
    return Object.keys(reducers).reduce((prevState, x) =&gt; {
      const reducer = reducers[x]
      return reducer ? { ...prevState, [x]: reducer(state, action) } : prevState
    }, {})
  }

  const sub = (...args) =&gt; {
    should.exist(args)
    args.should.have.lengthOf(2)
    const [type, callback] = args
    type.should.be.a(&apos;string&apos;)
      .that.matches(/^[A-Z_]+$/)
    callback.should.be.a(&apos;function&apos;)

    const subscribePayload = action =&gt; {
      if(!action.type)
        return
      if(action.type === type)
        callback(action.payload)
    }

    Array.from(forks.values()).forEach(x =&gt; x.on(&apos;message&apos;, subscribePayload))
    if(!orphan)
      process.on(&apos;message&apos;, subscribePayload)
  }

  /** IMPLEMENT THUNKS */
  const pub = action =&gt; {
    should.exist(action)
    action.should.be.an(&apos;object&apos;)
      .that.has.property(&apos;type&apos;)
        .that.is.a(&apos;string&apos;)
        .that.matches(/^[A-Z_]+$/)

    state = reduceState(state, action)

    /**
     * Publish down the tree, then up the tree
     * NEEDS TESTS
     */
    Array.from(forks.values()).forEach(x =&gt; x.send(action))
    if(!orphan)
      process.send(action)
  }

  const fork = (...args) =&gt; {
    args.length.should.be.above(0).and.below(5)
    return co(function* () {
      try {
        const [forkID, ...forkArgs] = args
        should.exist(forkID)
        forks.has(forkID).should.be.false
        const [modulePath, childArgs, options] = forkArgs
        should.exist(modulePath)
        modulePath.should.be.a(&apos;string&apos;)
        const env = { [PMUX]: forkID }
        const opts = options ? { ...options, env  } : { env }
        const lastArgs = childArgs ? [childArgs, opts] : [opts]
        const child = yield createFork({ timeoutMS })(modulePath, ...lastArgs)
        state[forkID] = {}
        /** TODO: RETURN A SPECIALIZED PUB / SUB FOR THIS SPECIFIC CHILD */
        return forks.set(forkID, child)
      } catch(err) {
        throw err
      }
    })
  }
  const getState = (...args) =&gt; {
    args.should.have.lengthOf(0)
    return state
  }
  const reducer = (...args) =&gt; {
    args.should.have.lengthOf(1)
    const [_reducer] = args
    _reducer.should.be.a(&apos;function&apos;)
    reducers[process.env[PMUX] || ROOT] = _reducer
  }
  const exit = (...args) =&gt; {
    args.length.should.be.below(2)
    const exitAction = { type: EXIT }
    /** TODO REDUCE FIRST? */
    pub({ type: EXIT })
    process.exit(0)
  }
  if(!orphan)
    process.send(pmuxAction(INIT, process.env[PMUX]))
  return { fork, pub, sub, getState, reducer, exit, orphan }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
